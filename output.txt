diff --git a/output.txt b/output.txt
index 68aa0a5..e69de29 100644
--- a/output.txt
+++ b/output.txt
@@ -1,1235 +0,0 @@
-diff --git a/vite.py b/vite.py
-index dab7a70..0e909a7 100644
---- a/vite.py
-+++ b/vite.py
-@@ -6,6 +6,7 @@ import math
- import datetime
- import bisect
- import re
-+import json
- gi.require_version("Gtk", "4.0")
- gi.require_version("Adw", "1")
- gi.require_version("Gdk", "4.0")
-@@ -4428,25 +4429,24 @@ class Renderer:
-                 'raw_string': hex_to_pango("#98c379"),   # Green
-                 'f_string': hex_to_pango("#98c379"),     # Green
-                 'string': hex_to_pango("#98c379"),       # Green
--                'raw_prefix': hex_to_pango("#c678dd"),   # Pink
--                
--                # String Delimiters (Start Tokens)
-+                'raw_prefix': hex_to_pango("#a626a4"),   # Pink
-+
-+                # String Delimiters
-                 'triple_start': hex_to_pango("#98c379"),
-                 'string_start': hex_to_pango("#98c379"),
-                 'f_triple_start': hex_to_pango("#98c379"),
-                 'f_string_start': hex_to_pango("#98c379"),
--                'b_triple_start': hex_to_pango("#56b6c2"), # Cyan for b"""
-+                'b_triple_start': hex_to_pango("#56b6c2"),
-                 'b_string_start': hex_to_pango("#56b6c2"),
--                'r_triple_start': hex_to_pango("#98c379"), # Green (content is raw)
-+                'r_triple_start': hex_to_pango("#98c379"),
-                 'r_string_start': hex_to_pango("#98c379"),
-                 'u_triple_start': hex_to_pango("#98c379"),
-                 'u_string_start': hex_to_pango("#98c379"),
- 
--                # New content tokens
--                'byte_string_content': hex_to_pango("#56b6c2"), # Cyan
--                'raw_string_content': hex_to_pango("#98c379"),  # Green (overlayable)
--                'f_string_content': hex_to_pango("#98c379"),    # Green
--                'string_content': hex_to_pango("#98c379"),      # Green
-+                'byte_string_content': hex_to_pango("#56b6c2"), 
-+                'raw_string_content': hex_to_pango("#98c379"),
-+                'f_string_content': hex_to_pango("#98c379"),
-+                'string_content': hex_to_pango("#98c379"),
-                 
-                 # DSL-specific colors (minimal - just muted tags)
-                 'header': hex_to_pango("#c678dd"),          # Purple for header directives
-@@ -4465,40 +4465,40 @@ class Renderer:
-                 'at_sign': hex_to_pango("#5c6370"),         # Muted grey
-             }
-         else:
--            self.text_foreground_color = (0.22, 0.23, 0.25) # Darker text for light mode
--            self.linenumber_foreground_color = (0.60, 0.60, 0.60)
--            self.selection_background_color = (0.85, 0.85, 0.90) # Subtler selection
-+            self.text_foreground_color = (0.2, 0.2, 0.2)
-+            self.linenumber_foreground_color = (0.6, 0.6, 0.6)
-+            self.selection_background_color = (0.8, 0.9, 1.0)
-             self.selection_foreground_color = (0.0, 0.0, 0.0)
-             
-             # Syntax Colors (Atom One Light)
-             self.syntax_colors = {
--                'keywords': hex_to_pango("#a626a4"),     # Purple
--                'builtins': hex_to_pango("#0184bc"),     # Cyan/Blue
--                'string': hex_to_pango("#50a14f"),       # Green
--                'comment': hex_to_pango("#a0a1a7"),      # Grey
--                'number': hex_to_pango("#986801"),       # Orange
--                'function': hex_to_pango("#4078f2"),     # Blue
--                'class': hex_to_pango("#c18401"),        # Orange/Gold
--                'decorator': hex_to_pango("#a626a4"),    # Purple
--                'personal': hex_to_pango("#e45649"),     # Red
--                'tag': hex_to_pango("#e45649"),          # Red
--                'attribute': hex_to_pango("#986801"),    # Orange
--                'property': hex_to_pango("#0184bc"),     # Cyan
--                'selector': hex_to_pango("#a626a4"),     # Purple
--                'macro': hex_to_pango("#c18401"),        # Orange
--                'preprocessor': hex_to_pango("#a626a4"), # Purple
--                'types': hex_to_pango("#0184bc"),        # Cyan
--                'entity': hex_to_pango("#986801"),       # Orange
--                'bool_ops': hex_to_pango("#986801"),     # Orange
--                'brackets': hex_to_pango("#986801"),     # Orange
--                'types': hex_to_pango("#0184bc"),        # Cyan
--                'entity': hex_to_pango("#986801"),       # Orange
--                'bool_ops': hex_to_pango("#986801"),     # Orange
--                'brackets': hex_to_pango("#986801"),     # Orange
--                'bool_ops': hex_to_pango("#986801"),     # Orange
--                'brackets': hex_to_pango("#a626a4"),     # Pink (Changed from Orange)
--                'raw_prefix': hex_to_pango("#a626a4"),   # Pink/Purple
--                'operators': hex_to_pango("#a626a4"),    # Pink/Purple
-+                'keywords': hex_to_pango("#a626a4"),
-+                'builtins': hex_to_pango("#0184bc"),
-+                'string': hex_to_pango("#50a14f"),
-+                'comment': hex_to_pango("#a0a1a7"),
-+                'number': hex_to_pango("#986801"),
-+                'function': hex_to_pango("#4078f2"),
-+                'class': hex_to_pango("#c18401"),
-+                'decorator': hex_to_pango("#a626a4"),
-+                'personal': hex_to_pango("#e45649"),
-+                'tag': hex_to_pango("#e45649"),
-+                'attribute': hex_to_pango("#986801"),
-+                'property': hex_to_pango("#0184bc"),
-+                'selector': hex_to_pango("#a626a4"),
-+                'macro': hex_to_pango("#c18401"),
-+                'preprocessor': hex_to_pango("#a626a4"),
-+                'types': hex_to_pango("#0184bc"),
-+                'entity': hex_to_pango("#986801"),
-+                'bool_ops': hex_to_pango("#986801"),
-+                'brackets': hex_to_pango("#986801"),
-+                'operators': hex_to_pango("#0184bc"),
-+                'regex': hex_to_pango("#50a14f"),
-+                'namespace': hex_to_pango("#c18401"),
-+                'special': hex_to_pango("#0184bc"),
-+                'file_ref': hex_to_pango("#a0a1a7"),        # Muted grey
-+                'escape': hex_to_pango("#a0a1a7"),          # Muted grey
-+                'tilde': hex_to_pango("#a0a1a7"),           # Muted grey
-+                'at_sign': hex_to_pango("#a0a1a7"),         # Muted grey
-                 'docstring': hex_to_pango("#50a14f"),    # Green
-                 'helpers': hex_to_pango("#e45649"),     # Red
-                 'argument': hex_to_pango("#986801"),     # Orange (New)
-@@ -4524,24 +4524,31 @@ class Renderer:
-                 'raw_string_content': hex_to_pango("#50a14f"),
-                 'f_string_content': hex_to_pango("#50a14f"),
-                 'string_content': hex_to_pango("#50a14f"),
--                
--                # DSL-specific colors (minimal - just muted tags)
--                'header': hex_to_pango("#a626a4"),          # Purple for header directives
--                'tag_bracket': hex_to_pango("#a0a1a7"),     # Muted grey
--                'color_tag': hex_to_pango("#a0a1a7"),       # Muted grey
--                'attr_tag': hex_to_pango("#a0a1a7"),        # Muted grey
--                'phonetic': hex_to_pango("#a0a1a7"),        # Muted grey
--                'pos_label': hex_to_pango("#a0a1a7"),       # Muted grey
--                'zone': hex_to_pango("#a0a1a7"),            # Muted grey
--                'stress': hex_to_pango("#a0a1a7"),          # Muted grey
--                'link': hex_to_pango("#a0a1a7"),            # Muted grey
--                'color_name': hex_to_pango("#a0a1a7"),      # Muted grey
--                'file_ref': hex_to_pango("#a0a1a7"),        # Muted grey
--                'escape': hex_to_pango("#a0a1a7"),          # Muted grey
--                'tilde': hex_to_pango("#a0a1a7"),           # Muted grey
--                'at_sign': hex_to_pango("#a0a1a7"),         # Muted grey
-             }
- 
-+    def set_font(self, font_desc):
-+        """Update font and recalculate metrics."""
-+        self.font = font_desc
-+        
-+        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
-+        cr = cairo.Context(surface)
-+
-+        layout = PangoCairo.create_layout(cr)
-+        layout.set_font_description(self.font)
-+        layout.set_text("Ag", -1)
-+
-+        ink_rect, logical_rect = layout.get_pixel_extents()
-+        self.text_h = logical_rect.height
-+        self.line_h = self.text_h
-+        
-+        # Calculate average character width dynamically
-+        layout.set_text("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", -1)
-+        ink, logical = layout.get_pixel_extents()
-+        self.avg_char_width = logical.width / 62.0
-+        
-+        # Invalidate wrap cache as metrics changed
-+
-+
- 
-     def create_text_layout(self, cr, text="", auto_dir=True):
-         """Create a Pango layout with standard settings.
-@@ -4556,6 +4563,14 @@ class Renderer:
-         """
-         layout = PangoCairo.create_layout(cr)
-         layout.set_font_description(self.font)
-+        
-+        # Apply tab width
-+        if hasattr(self, 'tab_width') and hasattr(self, 'avg_char_width'):
-+            tab_width_px = self.tab_width * self.avg_char_width
-+            tabs = Pango.TabArray.new(1, True)
-+            tabs.set_tab(0, Pango.TabAlign.LEFT, int(tab_width_px))
-+            layout.set_tabs(tabs)
-+
-         if auto_dir:
-             layout.set_auto_dir(True)
-         if text:
-@@ -4644,6 +4659,10 @@ class Renderer:
- 
-     def calculate_line_number_width(self, cr, total_lines):
-         """Calculate width needed for line numbers based on total lines"""
-+        # Return 2 pixels if line numbers are disabled (visual margin)
-+        if not getattr(self, "show_line_numbers", True):
-+            return 5
-+            
-         # Format the largest line number
-         max_line_num = str(total_lines)
-         width = self.get_text_width(cr, max_line_num)
-@@ -5511,7 +5530,8 @@ class Renderer:
- 
-                 # Draw current line highlight (extends from line number to viewport)
-                 # Use foreground color with 5% alpha
--                if ln == buf.cursor_line:
-+                highlight_current = getattr(buf, '_view', None) and getattr(buf._view, 'highlight_current_line', True)
-+                if ln == buf.cursor_line and highlight_current:
-                     r_fg, g_fg, b_fg = self.text_foreground_color
-                     
-                     cr.save()
-@@ -5531,8 +5551,9 @@ class Renderer:
-                     cr.set_source_rgb(*ln_fg)
-                     if vis_idx == 0:
-                         ln_text = str(ln + 1)
--                        # Make current line number bold
--                        if ln == buf.cursor_line:
-+                        # Make current line number bold if enabled
-+                        highlight_current = getattr(buf, '_view', None) and getattr(buf._view, 'highlight_current_line', True)
-+                        if ln == buf.cursor_line and highlight_current:
-                             layout.set_markup(f"<b>{ln_text}</b>", -1)
-                         else:
-                             layout.set_text(ln_text, -1)
-@@ -5632,6 +5653,56 @@ class Renderer:
-                                 cr.rectangle(h_x, y, h_w, self.line_h)
-                                 cr.fill()
- 
-+                # --- DRAW MATCHING BRACKETS ---
-+                if hasattr(self, 'matching_brackets') and self.matching_brackets:
-+                    # matching_brackets is list of (ln, col)
-+                    # Filter for current line
-+                    current_line_brackets = [b for b in self.matching_brackets if b[0] == ln]
-+                    
-+                    if current_line_brackets:
-+                        # Prepare layout for calc if not already set (re-use optimization idea)
-+                        final_text = text_segment if text_segment else " "
-+                        layout.set_text(final_text, -1)
-+                        
-+                        text_w, _ = layout.get_pixel_size()
-+                        rtl = line_is_rtl(text_segment)
-+                        base_x = self.calculate_text_base_x(rtl, text_w, alloc.width, ln_width, scroll_x)
-+
-+                        for b_ln, b_col in current_line_brackets:
-+                            # Check if bracket is in this visual line segment
-+                            if col_start <= b_col < col_end:
-+                                # Calculate position
-+                                rel_col = b_col - col_start
-+                                idx1 = visual_byte_index(text_segment, rel_col)
-+                                idx2 = visual_byte_index(text_segment, rel_col + 1)
-+                                
-+                                r1_strong, _ = layout.get_cursor_pos(idx1)
-+                                r2_strong, _ = layout.get_cursor_pos(idx2)
-+                                
-+                                x1 = r1_strong.x / Pango.SCALE
-+                                x2 = r2_strong.x / Pango.SCALE
-+                                
-+                                b_x = base_x + min(x1, x2)
-+                                b_w = abs(x2 - x1)
-+                                
-+                                if b_w > 0:
-+                                    # Draw box around bracket
-+                                    # Use Pango syntax color or specific color? 
-+                                    # Users usually expect a box or background.
-+                                    # Let's do a faint background + border
-+                                    
-+                                    # Background
-+                                    cr.set_source_rgba(0.6, 0.6, 0.6, 0.2)
-+                                    cr.rectangle(b_x, y, b_w, self.line_h)
-+                                    cr.fill()
-+                                    
-+                                    # Border
-+                                    cr.set_source_rgba(0.6, 0.6, 0.6, 0.8)
-+                                    cr.set_line_width(1)
-+                                    # Inset slightly to look nice
-+                                    cr.rectangle(b_x + 0.5, y + 0.5, b_w - 1, self.line_h - 1)
-+                                    cr.stroke()
-+
-                 # --- DRAW CURRENT MATCH EXTRA HIGHLIGHT ---
-                 # Drawn on top or differently?
-                 # If we passed is_current in search_matches, we handled it. 
-@@ -6057,6 +6128,8 @@ class VirtualTextView(Gtk.DrawingArea):
-         self.buf = buf
-         # Add reference from buffer to view for drag-and-drop
-         buf._view = self
-+        self.use_tabs = True
-+        self.auto_indent = True
-         self.renderer = Renderer()
-         self.ctrl = InputController(self, buf)
-         self.scroll_line = 0
-@@ -6091,6 +6164,10 @@ class VirtualTextView(Gtk.DrawingArea):
-         self.highlight_cache = {} # Dict {ln: [(start_col, end_col), ...]}
-         self.current_match_idx = -1
-         self.current_match = None
-+
-+        # Highlighting flags (default True, managed by settings)
-+        self.highlight_current_line = True
-+        self.highlight_brackets = True
-         
-         # Scroll callback for viewport-based search refresh
-         self.on_scroll_callback = None
-@@ -6118,6 +6195,14 @@ class VirtualTextView(Gtk.DrawingArea):
-         """
-         layout = PangoCairo.create_layout(cr)
-         layout.set_font_description(self.renderer.font)
-+
-+        # Apply tab width
-+        if hasattr(self.renderer, 'tab_width') and hasattr(self.renderer, 'avg_char_width'):
-+            tab_width_px = self.renderer.tab_width * self.renderer.avg_char_width
-+            tabs = Pango.TabArray.new(1, True)
-+            tabs.set_tab(0, Pango.TabAlign.LEFT, int(tab_width_px))
-+            layout.set_tabs(tabs)
-+
-         if auto_dir:
-             layout.set_auto_dir(True)
-         if text:
-@@ -7199,8 +7284,12 @@ class VirtualTextView(Gtk.DrawingArea):
-                     self.queue_draw()
-                     return True
-             
--            # Normal Tab (Insert spaces)
--            self.buf.insert_text("    ")
-+            # Normal Tab (Insert tabs or spaces)
-+            if getattr(self, "use_tabs", True):
-+                self.buf.insert_text("\t")
-+            else:
-+                tab_width = getattr(self.renderer, "tab_width", 4)
-+                self.buf.insert_text(" " * tab_width)
-             self.queue_draw()
-             return True
- 
-@@ -7279,6 +7368,22 @@ class VirtualTextView(Gtk.DrawingArea):
- 
-         if name == "Return":
-             self.buf.insert_newline()
-+            
-+            # Auto-indentation
-+            if getattr(self, "auto_indent", True):
-+                current_line_idx = self.buf.cursor_line - 1 # Line we just left
-+                if current_line_idx >= 0:
-+                    line_text = self.buf.get_line(current_line_idx)
-+                    indent = ""
-+                    for char in line_text:
-+                        if char in (" ", "\t"):
-+                            indent += char
-+                        else:
-+                            break
-+                    
-+                    if indent:
-+                        self.buf.insert_text(indent)
-+
-             self.keep_cursor_visible()
-             self.update_im_cursor_location()
-             self.queue_draw()
-@@ -7708,6 +7813,7 @@ class VirtualTextView(Gtk.DrawingArea):
-                 self.buf.selection.set_start(self.buf.cursor_line, self.buf.cursor_col)
-             self.buf.selection.set_end(ln, col)
-             self.buf.set_cursor(ln, col, extend_selection=True)
-+            self.update_matching_brackets()
-             self.queue_draw()
-             return
- 
-@@ -7736,6 +7842,7 @@ class VirtualTextView(Gtk.DrawingArea):
-             self.buf.selection.set_end(ln, line_len)
-             self.buf.cursor_line = ln
-             self.buf.cursor_col = line_len
-+            self.update_matching_brackets()
-             self.queue_draw()
-             return
- 
-@@ -7780,6 +7887,7 @@ class VirtualTextView(Gtk.DrawingArea):
-                 # Enable word selection mode for drag (treat empty lines as "words")
-                 self.word_selection_mode = True
-                 
-+                self.update_matching_brackets()
-                 self.queue_draw()
-                 return
- 
-@@ -7926,6 +8034,7 @@ class VirtualTextView(Gtk.DrawingArea):
-         self._click_ln = ln
-         self._click_col = col
- 
-+        self.update_matching_brackets()
-         self.queue_draw()
- 
- 
-@@ -8624,12 +8733,105 @@ class VirtualTextView(Gtk.DrawingArea):
-         self.queue_draw()
- 
- 
-+    def update_matching_brackets(self):
-+        """Find matching brackets and update renderer"""
-+        if not getattr(self, 'highlight_brackets', True):
-+            self.renderer.matching_brackets = []
-+            return
-+
-+        cursor_ln = self.buf.cursor_line
-+        cursor_col = self.buf.cursor_col
-+        line_text = self.buf.get_line(cursor_ln)
-+        
-+        matches = []
-+        
-+        # Check char at cursor (or char before cursor if at end of line/word)
-+        # Priority: char after cursor (what we are on), then char before cursor
-+        
-+        chars_to_check = []
-+        if cursor_col < len(line_text):
-+            chars_to_check.append((cursor_ln, cursor_col, line_text[cursor_col]))
-+        if cursor_col > 0:
-+            chars_to_check.append((cursor_ln, cursor_col - 1, line_text[cursor_col - 1]))
-+            
-+        params = {
-+            '(': (')', 1), ')': ('(', -1),
-+            '[': (']', 1), ']': ('[', -1),
-+            '{': ('}', 1), '}': ('{', -1),
-+            '<': ('>', 1), '>': ('<', -1)
-+        }
-+        
-+        found_start = None
-+        
-+        for ln, col, char in chars_to_check:
-+            if char in params:
-+                target, direction = params[char]
-+                found_start = (ln, col)
-+                
-+                # Scan for match
-+                depth = 1
-+                curr_ln = ln
-+                curr_col = col + direction
-+                
-+                total_lines = self.buf.total()
-+                # Limit scan lines to reasonable amount (e.g. 2000 lines)
-+                scan_limit = 2000
-+                lines_scanned = 0
-+                
-+                while 0 <= curr_ln < total_lines and lines_scanned < scan_limit:
-+                    text = self.buf.get_line(curr_ln)
-+                    
-+                    # Determine range to check in this line
-+                    if direction == 1:
-+                        # Forward
-+                        # if same line as start, start from col + 1 (already handled in curr_col init)
-+                        # else start from 0
-+                        start_c = curr_col if curr_ln == ln else 0
-+                        range_iter = range(start_c, len(text))
-+                    else:
-+                        # Backward
-+                        # if same line as start, start from col - 1
-+                        # else start from len(text) - 1
-+                        start_c = curr_col if curr_ln == ln else len(text) - 1
-+                        range_iter = range(start_c, -1, -1)
-+                        
-+                    curr_col_next = -1 # indicator to move to next line
-+                    
-+                    for c_idx in range_iter:
-+                        c = text[c_idx]
-+                        if c == char:
-+                            depth += 1
-+                        elif c == target:
-+                            depth -= 1
-+                            if depth == 0:
-+                                matches = [found_start, (curr_ln, c_idx)]
-+                                break
-+                    
-+                    if matches:
-+                        break
-+                        
-+                    # Move to next/prev line
-+                    curr_ln += direction
-+                    lines_scanned += 1
-+                    
-+                    # Reset col for new line
-+                    if 0 <= curr_ln < total_lines:
-+                        pass # Loop logic handles it
-+                
-+                if matches:
-+                    break
-+        
-+        self.renderer.matching_brackets = matches
-+        if matches:
-+            self.queue_draw()
-+
-     def keep_cursor_visible(self):
-         """Keep cursor visible by scrolling if necessary.
-         
-         OPTIMIZED: Quick check for obviously visible cursor to avoid
-         expensive visual line calculations during normal typing.
-         """
-+        self.update_matching_brackets()
-         cl = self.buf.cursor_line
-         cc = self.buf.cursor_col
- 
-@@ -9353,6 +9555,8 @@ class ChromeTab(Gtk.Box):
-     def get_title(self):
-         return self._original_title
-     
-+
-+
-     def update_label(self):
-         """Update the label text."""
-         self.label.set_text(self._original_title)
-@@ -9847,19 +10051,25 @@ class ChromeTabBar(Adw.WrapBox):
-                 dragged_tab.connect('activate-requested', target_window.on_tab_activated)
-                 dragged_tab.connect('close-requested', target_window.on_tab_close_requested)
- 
--                page = dragged_tab._page
--                # Transfer page to target window's tab view
--                source_window.tab_view.transfer_page(page, target_window.tab_view, drop_position)
--                
--                # Ensure the page is selected in the new window
--                def select_page():
--                    n_pages = target_window.tab_view.get_n_pages()
--                    if drop_position < n_pages:
--                        new_page = target_window.tab_view.get_nth_page(drop_position)
--                        if new_page:
--                            target_window.tab_view.set_selected_page(new_page)
-+                page = getattr(dragged_tab, '_page', None)
-+                if page:
-+                    # Transfer page to target window's tab view
-+                    # IMPORTANT: transfer_page returns the NEW Adw.TabPage belonging to the target view
-+                    new_page = source_window.tab_view.transfer_page(page, target_window.tab_view, drop_position)
-+                    
-+                    # Update the tab's page reference immediately
-+                    if new_page:
-+                        dragged_tab._page = new_page
-+                        
-+                        # Ensure the page is selected in the new window
-+                        def select_page():
-+                            if new_page.get_selected_page() != new_page:
-+                                 target_window.tab_view.set_selected_page(new_page)
-+                            return False
-+                        GLib.idle_add(select_page)
-+                else:
-+                    print("Error: dragged_tab has no _page")
-                     return False
--                GLib.idle_add(select_page)
-             
-             # 4. Activate the tab
-             self.set_tab_active(dragged_tab)
-@@ -9927,20 +10137,13 @@ class FindReplaceBar(Gtk.Box):
-         find_box.set_margin_start(12)
-         find_box.set_margin_end(12)
-         
--        # Toggle Replace Mode Button (Arrow)
--        self.reveal_replace_btn = Gtk.Button()
--        self.reveal_replace_btn.set_icon_name("pan-down-symbolic")
--        self.reveal_replace_btn.add_css_class("flat")
--        self.reveal_replace_btn.connect("clicked", self.toggle_replace_mode)
--        self.reveal_replace_btn.set_tooltip_text("Toggle Replace")
--        find_box.append(self.reveal_replace_btn)
--        
-         # Find Entry
-         self.find_entry = Gtk.SearchEntry()
-         self.find_entry.set_hexpand(True)
-         self.find_entry.set_placeholder_text("Find")
-         self.find_entry.connect("search-changed", self.on_search_changed)
-         self.find_entry.connect("activate", self.on_find_next)
-+        
-         # Capture Esc to close
-         key_ctrl = Gtk.EventControllerKey()
-         key_ctrl.connect("key-pressed", self.on_key_pressed)
-@@ -9948,22 +10151,6 @@ class FindReplaceBar(Gtk.Box):
-         
-         find_box.append(self.find_entry)
-         
--        # Options Box (linked)
--        opt_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
--        opt_box.add_css_class("linked")
--        
--        self.case_btn = Gtk.ToggleButton(label="Aa")
--        self.case_btn.set_tooltip_text("Case Sensitive")
--        self.case_btn.connect("toggled", self.on_search_changed)
--        opt_box.append(self.case_btn)
--        
--        self.regex_btn = Gtk.ToggleButton(label=".*")
--        self.regex_btn.set_tooltip_text("Regular Expression")
--        self.regex_btn.connect("toggled", self.on_search_changed)
--        opt_box.append(self.regex_btn)
--        
--        find_box.append(opt_box)
--        
-         # Navigation Box (linked)
-         nav_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
-         nav_box.add_css_class("linked")
-@@ -9979,6 +10166,48 @@ class FindReplaceBar(Gtk.Box):
-         nav_box.append(self.next_btn)
-         
-         find_box.append(nav_box)
-+
-+        # Toggle Replace Mode Button (Icon)
-+        self.reveal_replace_btn = Gtk.Button()
-+        self.reveal_replace_btn.set_icon_name("edit-find-replace-symbolic")
-+        self.reveal_replace_btn.add_css_class("flat")
-+        self.reveal_replace_btn.connect("clicked", self.toggle_replace_mode)
-+        self.reveal_replace_btn.set_tooltip_text("Toggle Replace")
-+        find_box.append(self.reveal_replace_btn)
-+
-+        # Search Options (Cog Wheel)
-+        self.options_btn = Gtk.MenuButton()
-+        self.options_btn.set_icon_name("system-run-symbolic") # or emblem-system-symbolic / preferences-system-symbolic
-+        self.options_btn.set_tooltip_text("Search Options")
-+        self.options_btn.add_css_class("flat")
-+        
-+        # Create Popover Content
-+        popover_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
-+        popover_box.set_margin_top(12)
-+        popover_box.set_margin_bottom(12)
-+        popover_box.set_margin_start(12)
-+        popover_box.set_margin_end(12)
-+        
-+        # Regex Option
-+        self.regex_check = Gtk.CheckButton(label="Regular Expressions")
-+        self.regex_check.connect("toggled", self.on_search_changed)
-+        popover_box.append(self.regex_check)
-+        
-+        # Case Option
-+        self.case_check = Gtk.CheckButton(label="Case Sensitive")
-+        self.case_check.connect("toggled", self.on_search_changed)
-+        popover_box.append(self.case_check)
-+        
-+        # Whole Word Option
-+        self.whole_word_check = Gtk.CheckButton(label="Match Whole Word Only")
-+        self.whole_word_check.connect("toggled", self.on_search_changed)
-+        popover_box.append(self.whole_word_check)
-+        
-+        self.options_popover = Gtk.Popover()
-+        self.options_popover.set_child(popover_box)
-+        self.options_btn.set_popover(self.options_popover)
-+        
-+        find_box.append(self.options_btn)
-         
-         # Close Button
-         close_btn = Gtk.Button(icon_name="window-close-symbolic")
-@@ -10097,13 +10326,28 @@ class FindReplaceBar(Gtk.Box):
-             self._cancel_search = None
-         
-         query = self.find_entry.get_text()
--        case_sensitive = self.case_btn.get_active()
--        is_regex = self.regex_btn.get_active()
-+        case_sensitive = self.case_check.get_active()
-+        is_regex = self.regex_check.get_active()
-+        whole_word = self.whole_word_check.get_active()
-         
-         if not query:
-             self.editor.view.set_search_results([])
-             self._current_search_query = None
-             return False
-+
-+        # Adjust query for Whole Word if not already regex (or if we want to force it)
-+        # If user selected Regex AND Whole Word, we typically wrap in \b...\b, 
-+        # but simplistic approach: if Whole Word, treat as regex \b...\b
-+        if whole_word:
-+            if not is_regex:
-+                # Escape the query so it's treated as literal text inside the regex
-+                import re
-+                escaped_query = re.escape(query)
-+                query = f"\\b{escaped_query}\\b"
-+                is_regex = True
-+            else:
-+                # If already regex, just wrap it
-+                query = f"\\b{query}\\b"
-         
-         # Store search params for viewport refresh
-         self._current_search_query = query
-@@ -10244,8 +10488,19 @@ class FindReplaceBar(Gtk.Box):
-     def on_replace_all(self, *args):
-         replacement = self.replace_entry.get_text()
-         query = self.find_entry.get_text()
--        case_sensitive = self.case_btn.get_active()
--        is_regex = self.regex_btn.get_active()
-+        case_sensitive = self.case_check.get_active()
-+        is_regex = self.regex_check.get_active()
-+        whole_word = self.whole_word_check.get_active()
-+        
-+        # Apply Whole Word logic
-+        if whole_word:
-+            if not is_regex:
-+                import re
-+                escaped_query = re.escape(query)
-+                query = f"\\b{escaped_query}\\b"
-+                is_regex = True
-+            else:
-+                query = f"\\b{query}\\b"
-         
-         total_lines = self.editor.buf.total()
-         
-@@ -10563,6 +10818,199 @@ class SaveChangesDialog(Adw.Window):
-         return None, False, None
- 
- 
-+class SettingsManager(GObject.Object):
-+    __gsignals__ = {
-+        'setting-changed': (GObject.SignalFlags.RUN_LAST, None, (str,)),
-+    }
-+
-+    def __init__(self):
-+        super().__init__()
-+        self.config_dir = os.path.join(GLib.get_user_config_dir(), "vite")
-+        self.config_file = os.path.join(self.config_dir, "settings.json")
-+        self.settings = {
-+            "font-size": 11,
-+            "word-wrap": True,
-+            "line-numbers": True,
-+            "theme": "System",
-+            "tab-width": 4,
-+            "use-tabs": False,
-+            "auto-indent": True,
-+            "highlight-current-line": True,
-+            "highlight-brackets": True,
-+        }
-+        self.load()
-+
-+    def load(self):
-+        try:
-+            os.makedirs(self.config_dir, exist_ok=True)
-+            if os.path.exists(self.config_file):
-+                with open(self.config_file, 'r') as f:
-+                    saved = json.load(f)
-+                    self.settings.update(saved)
-+        except Exception as e:
-+            print(f"Error loading settings: {e}")
-+
-+    def save(self):
-+        try:
-+            os.makedirs(self.config_dir, exist_ok=True)
-+            with open(self.config_file, 'w') as f:
-+                json.dump(self.settings, f, indent=4)
-+        except Exception as e:
-+            print(f"Error saving settings: {e}")
-+
-+    def get_setting(self, key):
-+        return self.settings.get(key)
-+
-+    def set_setting(self, key, value):
-+        if self.settings.get(key) != value:
-+            self.settings[key] = value
-+            self.save()
-+            self.emit("setting-changed", key)
-+
-+
-+class SettingsDialog(Adw.PreferencesWindow):
-+    def __init__(self, parent, settings_manager):
-+        super().__init__()
-+        self.set_transient_for(parent)
-+        self.set_modal(True)
-+        self.set_title("Preferences")
-+        self.settings = settings_manager
-+
-+        # Appearance Page
-+        page_appearance = Adw.PreferencesPage()
-+        page_appearance.set_title("Appearance")
-+        page_appearance.set_icon_name("preferences-desktop-display-symbolic")
-+
-+        # Display Group
-+        group_display = Adw.PreferencesGroup()
-+        group_display.set_title("Display")
-+
-+        # Line Numbers
-+        row_lines = Adw.ActionRow()
-+        row_lines.set_title("Show Line Numbers")
-+        switch_lines = Gtk.Switch()
-+        switch_lines.set_active(self.settings.get_setting("line-numbers"))
-+        switch_lines.set_valign(Gtk.Align.CENTER)
-+        switch_lines.connect("notify::active", lambda w, p: self.settings.set_setting("line-numbers", w.get_active()))
-+        row_lines.add_suffix(switch_lines)
-+        group_display.add(row_lines)
-+
-+        # Word Wrap
-+        row_wrap = Adw.ActionRow()
-+        row_wrap.set_title("Word Wrap")
-+        switch_wrap = Gtk.Switch()
-+        switch_wrap.set_active(self.settings.get_setting("word-wrap"))
-+        switch_wrap.set_valign(Gtk.Align.CENTER)
-+        switch_wrap.connect("notify::active", lambda w, p: self.settings.set_setting("word-wrap", w.get_active()))
-+        row_wrap.add_suffix(switch_wrap)
-+        group_display.add(row_wrap)
-+
-+        # Theme
-+        row_theme = Adw.ActionRow()
-+        row_theme.set_title("Theme")
-+        combo_theme = Gtk.ComboBoxText()
-+        combo_theme.append("System", "System")
-+        combo_theme.append("Light", "Light")
-+        combo_theme.append("Dark", "Dark")
-+
-+        current_theme = self.settings.get_setting("theme")
-+        if current_theme in ["System", "Light", "Dark"]:
-+            combo_theme.set_active_id(current_theme)
-+        else:
-+            combo_theme.set_active_id("System")
-+
-+        combo_theme.set_valign(Gtk.Align.CENTER)
-+        combo_theme.connect("changed", self.on_theme_combo_changed)
-+        row_theme.add_suffix(combo_theme)
-+        group_display.add(row_theme)
-+
-+        page_appearance.add(group_display)
-+        self.add(page_appearance)
-+
-+        # Editor Page
-+        page_editor = Adw.PreferencesPage()
-+        page_editor.set_title("Editor")
-+        page_editor.set_icon_name("accessories-text-editor-symbolic")
-+
-+        group_editor = Adw.PreferencesGroup()
-+        group_editor.set_title("Behavior")
-+
-+        # Use Tabs
-+        row_tabs = Adw.ActionRow()
-+        row_tabs.set_title("Use Tabs")
-+        row_tabs.set_subtitle("Insert real tabs (\\t) instead of spaces")
-+        switch_tabs = Gtk.Switch()
-+        switch_tabs.set_active(self.settings.get_setting("use-tabs"))
-+        switch_tabs.set_valign(Gtk.Align.CENTER)
-+        switch_tabs.connect("notify::active", lambda w, p: self.settings.set_setting("use-tabs", w.get_active()))
-+        row_tabs.add_suffix(switch_tabs)
-+        group_editor.add(row_tabs)
-+
-+        # Automatic Indentation
-+        row_indent = Adw.ActionRow()
-+        row_indent.set_title("Automatic Indentation")
-+        row_indent.set_subtitle("Preserve indentation on new line")
-+        switch_indent = Gtk.Switch()
-+        switch_indent.set_active(self.settings.get_setting("auto-indent"))
-+        switch_indent.set_valign(Gtk.Align.CENTER)
-+        switch_indent.connect("notify::active", lambda w, p: self.settings.set_setting("auto-indent", w.get_active()))
-+        row_indent.add_suffix(switch_indent)
-+        group_editor.add(row_indent)
-+
-+        # Highlighting Group
-+        group_highlight = Adw.PreferencesGroup()
-+        group_highlight.set_title("Highlighting")
-+
-+        # Highlight Current Line
-+        row_hl_line = Adw.ActionRow()
-+        row_hl_line.set_title("Highlight Current Line")
-+        switch_hl_line = Gtk.Switch()
-+        switch_hl_line.set_active(self.settings.get_setting("highlight-current-line"))
-+        switch_hl_line.set_valign(Gtk.Align.CENTER)
-+        switch_hl_line.connect("notify::active", lambda w, p: self.settings.set_setting("highlight-current-line", w.get_active()))
-+        row_hl_line.add_suffix(switch_hl_line)
-+        group_highlight.add(row_hl_line)
-+
-+        # Highlight Matching Brackets
-+        row_hl_brackets = Adw.ActionRow()
-+        row_hl_brackets.set_title("Highlight Matching Brackets")
-+        switch_hl_brackets = Gtk.Switch()
-+        switch_hl_brackets.set_active(self.settings.get_setting("highlight-brackets"))
-+        switch_hl_brackets.set_valign(Gtk.Align.CENTER)
-+        switch_hl_brackets.connect("notify::active", lambda w, p: self.settings.set_setting("highlight-brackets", w.get_active()))
-+        row_hl_brackets.add_suffix(switch_hl_brackets)
-+        group_highlight.add(row_hl_brackets)
-+
-+        page_editor.add(group_editor)
-+        page_editor.add(group_highlight)
-+
-+        # Font Size
-+        row_font = Adw.ActionRow()
-+        row_font.set_title("Font Size")
-+        spin_font = Gtk.SpinButton.new_with_range(8, 72, 1)
-+        spin_font.set_value(self.settings.get_setting("font-size"))
-+        spin_font.set_valign(Gtk.Align.CENTER)
-+        spin_font.connect("value-changed", lambda w: self.settings.set_setting("font-size", int(w.get_value())))
-+        row_font.add_suffix(spin_font)
-+        group_editor.add(row_font)
-+        
-+        # Tab Width
-+        row_tab = Adw.ActionRow()
-+        row_tab.set_title("Tab Width")
-+        spin_tab = Gtk.SpinButton.new_with_range(2, 8, 1)
-+        spin_tab.set_value(self.settings.get_setting("tab-width"))
-+        spin_tab.set_valign(Gtk.Align.CENTER)
-+        spin_tab.connect("value-changed", lambda w: self.settings.set_setting("tab-width", int(w.get_value())))
-+        row_tab.add_suffix(spin_tab)
-+        group_editor.add(row_tab)
-+
-+        self.add(page_editor)
-+
-+    def on_theme_combo_changed(self, combo):
-+        theme = combo.get_active_id()
-+        if theme:
-+            self.settings.set_setting("theme", theme)
-+
- class EditorWindow(Adw.ApplicationWindow):
-     def __init__(self, app):
-         super().__init__(application=app)
-@@ -10640,8 +11088,13 @@ class EditorWindow(Adw.ApplicationWindow):
-         # Add menu button
-         menu_button = Gtk.MenuButton()
-         menu_button.set_icon_name("open-menu-symbolic")
--        menu_button.set_menu_model(self.create_menu())
--#        menu_button.set_size_request(16, 20)
-+        
-+        # Create PopoverMenu from model but add custom child for zoom
-+        menu_model = self.create_menu()
-+        popover = Gtk.PopoverMenu.new_from_model(menu_model)
-+        popover.add_child(self._create_zoom_widget(), "zoom_controls")
-+        
-+        menu_button.set_popover(popover)
-         self.header.pack_end(menu_button)
- 
-         # Tab dropdown button (for file list)
-@@ -10668,12 +11121,16 @@ class EditorWindow(Adw.ApplicationWindow):
-         # Setup actions
-         self.setup_actions()
-         self.setup_tab_actions()
-+
-+        # Connect to settings
-+        self.get_application().settings_manager.connect("setting-changed", self.on_setting_changed_win)
-         
-         # Add initial tab
-         self.add_tab()
-         
-         # Add key controller for shortcuts (Ctrl+Tab)
-         key_ctrl = Gtk.EventControllerKey()
-+        key_ctrl.set_propagation_phase(Gtk.PropagationPhase.CAPTURE)
-         key_ctrl.connect("key-pressed", self.on_window_key_pressed)
-         self.add_controller(key_ctrl)
-         
-@@ -10742,6 +11199,25 @@ class EditorWindow(Adw.ApplicationWindow):
-                     new_page = self.tab_view.get_nth_page(new_idx)
-                     self.tab_view.set_selected_page(new_page)
-                     return True
-+
-+            # Intercept Ctrl+Home/End to prevent tab switching (Adw.TabView default)
-+            # and force editor navigation instead
-+            elif keyval in (Gdk.KEY_Home, Gdk.KEY_End, Gdk.KEY_KP_Home, Gdk.KEY_KP_End):
-+                page = self.tab_view.get_selected_page()
-+                if page:
-+                    root = page.get_child()
-+                    if hasattr(root, '_editor'):
-+                        editor = root._editor
-+                        shift = bool(state & Gdk.ModifierType.SHIFT_MASK)
-+                        
-+                        if keyval in (Gdk.KEY_Home, Gdk.KEY_KP_Home):
-+                            editor.view.ctrl.move_document_start(extend_selection=shift)
-+                        else:
-+                            editor.view.ctrl.move_document_end(extend_selection=shift)
-+                        
-+                        editor.view.keep_cursor_visible()
-+                        editor.view.queue_draw()
-+                        return True
-             
-             # Ctrl+T: New Tab
-             elif keyval == Gdk.KEY_t or keyval == Gdk.KEY_T:
-@@ -10992,6 +11468,9 @@ class EditorWindow(Adw.ApplicationWindow):
-         # Update UI state
-         self.update_ui_state()
- 
-+        # Apply settings
-+        self.apply_settings_to_editor(editor)
-+
-         return editor
- 
-     def _create_editor_overlay(self, editor, add_close_button=False):
-@@ -11310,6 +11789,12 @@ class EditorWindow(Adw.ApplicationWindow):
-         
-         # Close the original page (it's now empty, so this is fast)
-         self.tab_view.close_page(page)
-+
-+    def grab_focus_editor(self):
-+        """Helper to grab focus on the current editor view"""
-+        editor = self.get_current_page()
-+        if editor:
-+            editor.view.grab_focus()
-         
-         # Remove the chrome tab
-         for tab in self.tab_bar.tabs:
-@@ -11868,27 +12353,69 @@ class EditorWindow(Adw.ApplicationWindow):
-         # Update dropdown
-         self.update_tab_dropdown()
-     
-+
-+
-     def create_menu(self):
--        """Create the application menu"""
-+        """Create the application menu model"""
-         menu = Gio.Menu()
-         
--        # File section
--        file_section = Gio.Menu()
--        file_section.append("Save As...", "win.save-as")
--        menu.append_section("File", file_section)
--        
--        # Encoding section with submenu
-+        # Actions
-+        menu.append("New Window", "win.new_window")
-+        menu.append("Find...", "win.find")
-+        menu.append("Save", "win.save")
-+        menu.append("Save As...", "win.save-as")
-+        menu.append("Save Copy As...", "win.save-copy")
-+        
-+        # Zoom Section (Custom Widget)
-+        # We use a placeholder item with a custom attribute
-+        zoom_item = Gio.MenuItem.new("Zoom", None)
-+        zoom_item.set_attribute_value("custom", GLib.Variant.new_string("zoom_controls"))
-+        menu.append_item(zoom_item)
-+        
-+        # View Submenu
-+        view_submenu = Gio.Menu()
-+        view_submenu.append("Show Line Numbers", "win.toggle_line_numbers")
-+        view_submenu.append("Word Wrap", "win.toggle_word_wrap")
-+        menu.append_submenu("View", view_submenu)
-+    
-+        # Encoding Submenu
-         encoding_submenu = Gio.Menu()
-         encoding_submenu.append("UTF-8", "win.encoding::utf-8")
-         encoding_submenu.append("UTF-8 with BOM", "win.encoding::utf-8-sig")
-         encoding_submenu.append("UTF-16 LE", "win.encoding::utf-16le")
-         encoding_submenu.append("UTF-16 BE", "win.encoding::utf-16be")
--        
--        encoding_section = Gio.Menu()
--        encoding_section.append_submenu("Encoding", encoding_submenu)
--        menu.append_section(None, encoding_section)
-+        menu.append_submenu("Encoding", encoding_submenu)
-+
-+        menu.append("Preferences", "win.preferences")
-         
-         return menu
-+
-+    def _create_zoom_widget(self):
-+        zoom_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
-+        zoom_box.set_halign(Gtk.Align.FILL)
-+        zoom_box.add_css_class("linked")
-+        zoom_box.set_margin_bottom(6)
-+        zoom_box.set_margin_top(6)
-+        zoom_box.set_margin_start(12)
-+        zoom_box.set_margin_end(12)
-+
-+        btn_minus = Gtk.Button(label="-")
-+        btn_minus.set_action_name("win.zoom_out")
-+        btn_minus.set_hexpand(True)
-+        
-+        btn_reset = Gtk.Button(label="100%")
-+        btn_reset.set_action_name("win.zoom_reset")
-+        btn_reset.add_css_class("flat") # Make it look like a label
-+        btn_reset.set_hexpand(True)
-+        
-+        btn_plus = Gtk.Button(label="+")
-+        btn_plus.set_action_name("win.zoom_in")
-+        btn_plus.set_hexpand(True)
-+        
-+        zoom_box.append(btn_minus)
-+        zoom_box.append(btn_reset)
-+        zoom_box.append(btn_plus)
-+        return zoom_box
-     
-     def update_tab_dropdown(self):
-         """Update the tab dropdown menu with file list"""
-@@ -11910,10 +12437,23 @@ class EditorWindow(Adw.ApplicationWindow):
-     
-     def setup_actions(self):
-         """Setup window actions for menu items"""
--        # Save As action
--        save_as_action = Gio.SimpleAction.new("save-as", None)
--        save_as_action.connect("activate", self.on_save_as)
--        self.add_action(save_as_action)
-+        # File Actions
-+        self.add_simple_action("new_tab", self.on_new_tab)
-+        self.add_simple_action("new_window", self.on_new_window)
-+        self.add_simple_action("open", lambda *_: self.open_file())
-+        self.add_simple_action("save", self.on_save)
-+        self.add_simple_action("save-as", self.on_save_as)
-+        self.add_simple_action("save-copy", self.on_save_copy)
-+        
-+        # View Actions (Toggles)
-+        self.add_simple_action("toggle_line_numbers", self.on_toggle_line_numbers)
-+        self.add_simple_action("toggle_word_wrap", self.on_toggle_word_wrap)
-+        self.add_simple_action("zoom_in", self.on_zoom_in)
-+        self.add_simple_action("zoom_out", self.on_zoom_out)
-+        self.add_simple_action("zoom_reset", self.on_zoom_reset)
-+
-+        # Tools
-+        self.add_simple_action("preferences", self.on_preferences)
-         
-         # Encoding action with parameter
-         encoding_action = Gio.SimpleAction.new_stateful(
-@@ -11924,7 +12464,7 @@ class EditorWindow(Adw.ApplicationWindow):
-         encoding_action.connect("activate", self.on_encoding_changed)
-         self.add_action(encoding_action)
-         
--        # Tab activate action (for dropdown menu)
-+        # Tab activate action
-         tab_activate_action = Gio.SimpleAction.new("tab_activate", GLib.VariantType.new("i"))
-         tab_activate_action.connect("activate", self.on_tab_activate_from_menu)
-         self.add_action(tab_activate_action)
-@@ -11938,6 +12478,133 @@ class EditorWindow(Adw.ApplicationWindow):
-         clear_recent_action = Gio.SimpleAction.new("clear_recent", None)
-         clear_recent_action.connect("activate", self.on_clear_recent)
-         self.add_action(clear_recent_action)
-+
-+
-+    def add_simple_action(self, name, callback):
-+        action = Gio.SimpleAction.new(name, None)
-+        action.connect("activate", callback)
-+        self.add_action(action)
-+
-+    def on_new_window(self, action, param):
-+        app = self.get_application()
-+        win = EditorWindow(app)
-+        win.present()
-+
-+    def on_save(self, action, param):
-+        editor = self.get_current_page()
-+        if editor:
-+            if editor.current_file_path:
-+                self.save_file(editor, editor.current_file_path)
-+            else:
-+                self.on_save_as(action, param)
-+
-+    def on_save_copy(self, action, param):
-+        editor = self.get_current_page()
-+        if not editor: return
-+        
-+        def on_save(dialog, result):
-+            try:
-+                gfile = dialog.save_finish(result)
-+                path = gfile.get_path()
-+                text = editor.get_text()
-+                with open(path, 'w', encoding=editor.current_encoding) as f:
-+                    f.write(text)
-+            except Exception as e:
-+                print(f"Error saving copy: {e}")
-+
-+        dialog = Gtk.FileDialog()
-+        dialog.save(self, None, on_save)
-+
-+    def on_preferences(self, action, param):
-+        dlg = SettingsDialog(self, self.get_application().settings_manager)
-+        dlg.present()
-+
-+    def on_toggle_line_numbers(self, action, param):
-+        manager = self.get_application().settings_manager
-+        current = manager.get_setting("line-numbers")
-+        manager.set_setting("line-numbers", not current)
-+        self.grab_focus_editor()
-+
-+    def on_toggle_word_wrap(self, action, param):
-+        manager = self.get_application().settings_manager
-+        current = manager.get_setting("word-wrap")
-+        manager.set_setting("word-wrap", not current)
-+        self.grab_focus_editor()
-+
-+    def on_zoom_in(self, action, param):
-+        manager = self.get_application().settings_manager
-+        current = manager.get_setting("font-size")
-+        manager.set_setting("font-size", current + 1)
-+        self.grab_focus_editor()
-+
-+    def on_zoom_out(self, action, param):
-+        manager = self.get_application().settings_manager
-+        current = manager.get_setting("font-size")
-+        if current > 8:
-+            manager.set_setting("font-size", current - 1)
-+        self.grab_focus_editor()
-+
-+    def on_zoom_reset(self, action, param):
-+        manager = self.get_application().settings_manager
-+        manager.set_setting("font-size", 11)
-+        self.grab_focus_editor()
-+
-+    def on_setting_changed_win(self, manager, key):
-+        # Update all tabs
-+        for i in range(self.tab_view.get_n_pages()):
-+            page = self.tab_view.get_nth_page(i)
-+            editor = page.get_child()._editor
-+            self.apply_settings_to_editor(editor)
-+
-+    def apply_settings_to_editor(self, editor):
-+        app = self.get_application()
-+        if not app:
-+            app = Gio.Application.get_default()
-+        
-+        if not app or not hasattr(app, 'settings_manager'):
-+            return
-+
-+        manager = app.settings_manager
-+        # Font size
-+        font_size = manager.get_setting("font-size")
-+        editor.view.renderer.set_font(Pango.FontDescription(f"Monospace {font_size}"))
-+        
-+        # Word wrap - handle state change properly
-+        new_wrap = manager.get_setting("word-wrap")
-+        if getattr(editor.view.renderer, 'wrap_enabled', False) != new_wrap:
-+            editor.view.renderer.wrap_enabled = new_wrap
-+            # Clear caches and force recalculation
-+            editor.view.renderer.wrap_cache = {}
-+            editor.view.renderer.visual_line_map = []
-+            editor.view.renderer.total_visual_lines_locked = False
-+            editor.view.renderer.visual_line_anchor = (0, 0)
-+            
-+            # Reset scroll if needed or re-adjust
-+            if new_wrap:
-+                editor.view.renderer.max_line_width = 0
-+                editor.view.scroll_x = 0
-+                editor.view.hadj.set_value(0)
-+            
-+            # Recalculate everything
-+            editor.view.on_resize(editor.view, editor.view.get_width(), editor.view.get_height())
-+        
-+        # Line numbers
-+        editor.view.renderer.show_line_numbers = manager.get_setting("line-numbers")
-+        
-+        # Tab width
-+        editor.view.renderer.tab_width = manager.get_setting("tab-width")
-+        
-+        # Use Tabs
-+        editor.view.use_tabs = manager.get_setting("use-tabs")
-+
-+        # Auto Indent
-+        editor.view.auto_indent = manager.get_setting("auto-indent")
-+
-+        # Highlighting
-+        editor.view.highlight_current_line = manager.get_setting("highlight-current-line")
-+        editor.view.highlight_brackets = manager.get_setting("highlight-brackets")
-+
-+        editor.view.queue_draw()
-     
-     def on_open_recent(self, action, parameter):
-         """Handle opening a recent file"""
-@@ -12384,6 +13051,24 @@ class VirtualTextEditor(Adw.Application):
-         super().__init__(application_id="io.github.fastrizwaan.vite",
-                          flags=Gio.ApplicationFlags.HANDLES_OPEN)
-         self.files_to_open = []
-+        self.settings_manager = SettingsManager()
-+        self.settings_manager.connect("setting-changed", self.on_setting_changed)
-+        # Apply initial theme
-+        self.apply_theme()
-+
-+    def on_setting_changed(self, manager, key):
-+        if key == "theme":
-+            self.apply_theme()
-+
-+    def apply_theme(self):
-+        theme = self.settings_manager.get_setting("theme")
-+        style_manager = Adw.StyleManager.get_default()
-+        if theme == "Dark":
-+            style_manager.set_color_scheme(Adw.ColorScheme.FORCE_DARK)
-+        elif theme == "Light":
-+            style_manager.set_color_scheme(Adw.ColorScheme.FORCE_LIGHT)
-+        else:
-+            style_manager.set_color_scheme(Adw.ColorScheme.DEFAULT)
- 
-     
-     def update_scrollbar_css(self, r, g, b, a):
diff --git a/vite.py b/vite.py
index b7c093c..07dede5 100644
--- a/vite.py
+++ b/vite.py
@@ -664,6 +664,12 @@ class SyntaxEngine:
     # Cache invalidation
     # -----------------------------
     def invalidate_from(self, start_line):
+        if start_line == 0:
+            # Optimization for "Select All" -> Delete/Cut
+            self.cache.clear()
+            self.line_states.clear()
+            return
+
         keys_to_del = [k for k in self.cache if k >= start_line]
         for k in keys_to_del:
             del self.cache[k]
@@ -1211,6 +1217,24 @@ class IndexedFile:
         raw = self.mm[start:end]
         return raw.decode(self.encoding, errors="replace").rstrip("\n\r")
 
+    def get_byte_range(self, start_line, end_line):
+        """Get raw bytes for a range of lines [start_line, end_line)"""
+        if self.is_empty:
+            return b""
+            
+        total = self.total_lines()
+        if start_line >= total:
+            return b""
+            
+        end_line = min(end_line, total)
+        if start_line >= end_line:
+            return b""
+            
+        start_idx = self.index[start_line]
+        end_idx = self.index[end_line]
+        
+        return self.mm[start_idx:end_idx]
+
 
 # ============================================================
 #   SELECTION
@@ -1327,28 +1351,42 @@ class UndoCommand:
 
 
 class InsertCommand(UndoCommand):
-    def __init__(self, line, col, text, cursor_after_line, cursor_after_col):
+    def __init__(self, line, col, text, cursor_after_line, cursor_after_col, lines=None):
         self.line = line
         self.col = col
         self.text = text
+        self.lines = lines
+        
+        # Memory Optimization: If direct lines list provided, don't store full text
+        # This allows sharing string objects with the buffer's inserted_lines
+        if self.lines and len(self.lines) > 100:
+             self.text = None
+
         self.cursor_after_line = cursor_after_line
         self.cursor_after_col = cursor_after_col
         self.timestamp = time.time()
         
     def undo(self, buffer):
         # To undo an insertion, we delete the inserted range.
-        # We know where it started (line, col) and how long text is.
-        # However, calculating the exact end line/col from text is safer than relying on stored end state,
-        # but for now we can rely on inverse logic.
+        # We know where it started (line, col).
         
-        # Calculate end position based on text content
-        lines = self.text.split('\n')
-        if len(lines) == 1:
-            end_line = self.line
-            end_col = self.col + len(self.text)
+        if self.lines:
+            lines_count = len(self.lines)
+            if lines_count == 1:
+                end_line = self.line
+                end_col = self.col + len(self.lines[0])
+            else:
+                end_line = self.line + lines_count - 1
+                end_col = len(self.lines[-1])
         else:
-            end_line = self.line + len(lines) - 1
-            end_col = len(lines[-1])
+            # Fallback for legacy commands or small edits
+            text_lines = self.text.split('\n')
+            if len(text_lines) == 1:
+                end_line = self.line
+                end_col = self.col + len(self.text)
+            else:
+                end_line = self.line + len(text_lines) - 1
+                end_col = len(text_lines[-1])
             
         # Select the range
         buffer.selection.set_start(self.line, self.col)
@@ -1365,7 +1403,14 @@ class InsertCommand(UndoCommand):
         buffer.cursor_line = self.line
         buffer.cursor_col = self.col
         buffer.selection.clear()
-        buffer.insert_text(self.text, _record_undo=False)
+        
+        # Reconstruct text if needed
+        if self.text is None and self.lines:
+            text_to_insert = '\n'.join(self.lines)
+        else:
+            text_to_insert = self.text
+            
+        buffer.insert_text(text_to_insert, _record_undo=False)
         
         # Restore cursor
         buffer.cursor_line = self.cursor_after_line
@@ -1377,13 +1422,21 @@ class InsertCommand(UndoCommand):
             
         # Check if other immediately follows self
         # We need to know where 'self' ended.
-        lines = self.text.split('\n')
-        if len(lines) == 1:
-            my_end_line = self.line
-            my_end_col = self.col + len(self.text)
+        if self.lines:
+            if len(self.lines) == 1:
+                my_end_line = self.line
+                my_end_col = self.col + len(self.lines[0])
+            else:
+                my_end_line = self.line + len(self.lines) - 1
+                my_end_col = len(self.lines[-1])
         else:
-            my_end_line = self.line + len(lines) - 1
-            my_end_col = len(lines[-1])
+            lines = self.text.split('\n')
+            if len(lines) == 1:
+                my_end_line = self.line
+                my_end_col = self.col + len(self.text)
+            else:
+                my_end_line = self.line + len(lines) - 1
+                my_end_col = len(lines[-1])
             
         if other.line != my_end_line or other.col != my_end_col:
             return False
@@ -1394,6 +1447,10 @@ class InsertCommand(UndoCommand):
         if other.timestamp - self.timestamp > 2.0:
             return False
             
+        # If we have complex lines structure (paste), don't merge simple typing
+        if self.lines or other.lines:
+            return False
+
         def group_type(txt):
             if not txt: return 0
             if txt.isspace(): return 1 # Whitespace
@@ -1806,6 +1863,93 @@ class VirtualBuffer(GObject.Object):
             line = self.get_line(start_line)
             return line[start_col:end_col]
         else:
+            # OPTIMIZATION for large files
+            can_optimize = False
+            offset = 0
+            
+            if self.file:
+                # 1. Simple Case: Global pristine (fastest)
+                if not self.edits and not self.inserted_lines and not self.deleted_lines:
+                    can_optimize = True
+                    offset = 0
+                else:
+                    # 2. Robust Case: Check for conflicts in the specific range
+                    conflict = False
+                    LIMIT = 1000 # If too many edits, skip scan to avoid overhead
+                    
+                    if len(self.edits) > LIMIT or len(self.inserted_lines) > LIMIT or len(self.deleted_lines) > LIMIT:
+                        conflict = True
+                    else:
+                        range_start = start_line + 1
+                        range_end = end_line
+                        
+                        # Check edits
+                        if not conflict:
+                            for k in self.edits:
+                                if range_start <= k < range_end:
+                                    conflict = True; break
+                        # Check insertions
+                        if not conflict:
+                            for k in self.inserted_lines:
+                                if range_start <= k < range_end:
+                                    conflict = True; break
+                        # Check deletions
+                        if not conflict:
+                            for k in self.deleted_lines:
+                                if range_start <= k < range_end:
+                                    conflict = True; break
+                    
+                    if not conflict:
+                        # Check and calculate offset
+                        current_offset = 0
+                        # line_offsets is sorted by logical line
+                        # We need the offset applicable at start_line+1
+                        # And ensure no new offset starts within the range
+                        for ln, off in self.line_offsets:
+                            if ln <= range_start:
+                                current_offset = off
+                            elif ln < range_end:
+                                # Offset changes inside our range
+                                conflict = True
+                                break
+                        
+                        if not conflict:
+                            can_optimize = True
+                            offset = current_offset
+
+            if can_optimize and end_line > start_line + 1:
+                try:
+                    # Map logical to physical
+                    # physical = logical - offset
+                    # range_start (logical) -> phys_start
+                    # range_end (logical) -> phys_end
+                    
+                    phys_start = (start_line + 1) - offset
+                    phys_end = end_line - offset
+                    
+                    # Sanity check physical bounds
+                    if phys_start >= 0 and phys_end > phys_start:
+                        # Get first line part
+                        first_line = self.get_line(start_line)
+                        first_part = first_line[start_col:]
+                        
+                        # Get last line part
+                        last_line = self.get_line(end_line)
+                        last_part = last_line[:end_col]
+                        
+                        # Get middle block directly from file
+                        raw_bytes = self.file.get_byte_range(phys_start, phys_end)
+                        
+                        # Decode and normalizew
+                        middle_text = raw_bytes.decode(self.file.encoding, errors='replace')
+                        
+                        if '\r' in middle_text:
+                            middle_text = middle_text.replace('\r\n', '\n').replace('\r', '\n')
+                        
+                        return first_part + "\n" + middle_text + last_part
+                except Exception as e:
+                    print(f"Error in optimized copy: {e}, falling back")
+            
             lines = []
             first_line = self.get_line(start_line)
             lines.append(first_line[start_col:])
@@ -1818,7 +1962,7 @@ class VirtualBuffer(GObject.Object):
             
             return '\n'.join(lines)
     
-    def delete_selection(self, _record_undo=True, restore_selection_on_undo=True):
+    def delete_selection(self, _record_undo=True, restore_selection_on_undo=True, provided_text=None):
         """Delete the selected text"""
         if not self.selection.has_selection():
             return False
@@ -1828,7 +1972,10 @@ class VirtualBuffer(GObject.Object):
         start_line, start_col, end_line, end_col = self.selection.get_bounds()
 
         if _record_undo:
-             deleted_text = self.get_selected_text()
+             if provided_text is not None:
+                 deleted_text = provided_text
+             else:
+                 deleted_text = self.get_selected_text()
         
         if start_line == end_line:
             # Single line selection
@@ -2031,7 +2178,10 @@ class VirtualBuffer(GObject.Object):
         self.selection.clear()
         
         if _record_undo:
-            cmd = InsertCommand(start_ln, start_col, text, self.cursor_line, self.cursor_col)
+            # OPTIMIZATION: Pass 'parts' (list of strings) to InsertCommand
+            # This allows sharing string objects between buffer and undo stack,
+            # preventing memory duplication for huge pastes.
+            cmd = InsertCommand(start_ln, start_col, text, self.cursor_line, self.cursor_col, lines=parts)
             self.undo_stack.add_command(cmd)
 
         self.syntax_engine.invalidate_from(start_ln)
@@ -4357,6 +4507,9 @@ class Renderer:
         # Colors - will be updated based on theme
         self.update_colors_for_theme()
 
+        # Cache for line number width to ensure hit testing matches rendering
+        self.last_ln_width = None
+
     def hex_to_rgba_floats(self, hex_str, alpha=1.0):
         hex_str = hex_str.lstrip('#')
         r = int(hex_str[0:2], 16) / 255.0
@@ -4530,21 +4683,30 @@ class Renderer:
         """Update font and recalculate metrics."""
         self.font = font_desc
         
+        # Recalculate average character width
         surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
         cr = cairo.Context(surface)
-
         layout = PangoCairo.create_layout(cr)
         layout.set_font_description(self.font)
-        layout.set_text("Ag", -1)
-
-        ink_rect, logical_rect = layout.get_pixel_extents()
-        self.text_h = logical_rect.height
-        self.line_h = self.text_h
+        layout.set_text("M", -1)
+        w, h = layout.get_pixel_size()
+        self.avg_char_width = max(1, w)
+        self.line_h = max(1, h)
         
-        # Calculate average character width dynamically
-        layout.set_text("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", -1)
-        ink, logical = layout.get_pixel_extents()
-        self.avg_char_width = logical.width / 62.0
+        # Cache TabArray
+        if hasattr(self, 'tab_width'):
+            tab_width_px = self.tab_width * self.avg_char_width
+            self.tab_array = Pango.TabArray.new(1, True)
+            self.tab_array.set_tab(0, Pango.TabAlign.LEFT, int(tab_width_px))
+        else:
+            self.tab_array = None
+
+        # Reset caches that depend on metrics
+        self.invalidate_wrap_cache()
+        if hasattr(self, 'total_visual_lines_cache'):
+            self.total_visual_lines_cache = None
+        if hasattr(self, 'estimated_total_cache'):
+            self.estimated_total_cache = None
         
         # Invalidate wrap cache as metrics changed
 
@@ -4582,6 +4744,7 @@ class Renderer:
         layout = self.create_text_layout(cr)
         total = buf.total()
         ln_width = self.calculate_line_number_width(cr, total)
+        self.last_ln_width = ln_width # Cache for consistency
         max_width = 0
         
         # Scan first 1000 lines to get a quick estimate
@@ -4613,6 +4776,7 @@ class Renderer:
         max_width = 0
         total = buf.total()
         ln_width = self.calculate_line_number_width(cr, total)
+        self.last_ln_width = ln_width # Cache for consistency
         
         # Check all lines
         for ln in range(total):
@@ -4681,6 +4845,9 @@ class Renderer:
         layout = PangoCairo.create_layout(cr)
         layout.set_font_description(self.font)
         layout.set_auto_dir(True)
+        if hasattr(self, 'tab_array') and self.tab_array:
+            layout.set_tabs(self.tab_array)
+            
         layout.set_text(text, -1)
         layout.set_width(max_width * Pango.SCALE)  # Set wrap width in Pango units
         layout.set_wrap(Pango.WrapMode.WORD_CHAR)  # Smart wrap: prefer words, fall back to char
@@ -4698,10 +4865,11 @@ class Renderer:
             start_index = line.start_index
             length = line.length
             
-            # Convert byte indices to character indices
-            start_col = len(text.encode('utf-8')[:start_index].decode('utf-8'))
+            # Safe, non-incremental conversion
+            # This is O(N^2) but robust and guaranteed to work if Pango works
+            start_col = len(text.encode('utf-8')[:start_index].decode('utf-8', errors='replace'))
             end_byte = start_index + length
-            end_col = len(text.encode('utf-8')[:end_byte].decode('utf-8'))
+            end_col = len(text.encode('utf-8')[:end_byte].decode('utf-8', errors='replace'))
             
             wrap_points.append((start_col, end_col))
         
@@ -4994,17 +5162,9 @@ class Renderer:
                 dist = logical_line - current_ln
                 
                 # Check if we can use optimization (either have cache or file stats)
-                if not (hasattr(self, 'total_visual_lines_cache') and self.total_visual_lines_cache):
-                     if not (hasattr(self, 'estimated_total_cache') and self.estimated_total_cache):
-                         # Force calculation of estimate if missing
-                         self.get_total_visual_lines(cr, buf, ln_width, viewport_width)
-
                 can_optimize = False
                 if hasattr(self, 'total_visual_lines_cache') and self.total_visual_lines_cache:
                     can_optimize = True
-                elif hasattr(self, 'estimated_total_cache') and self.estimated_total_cache:
-                    # NEW: Use estimated cache
-                    can_optimize = True
                 elif hasattr(buf, 'file') and buf.file and hasattr(buf.file, 'mm'):
                     can_optimize = True
 
@@ -5019,10 +5179,6 @@ class Renderer:
                      if hasattr(self, 'total_visual_lines_cache') and self.total_visual_lines_cache:
                          est_visual_per_line = self.total_visual_lines_cache / max(1, total_logical)
                      
-                     # NEW: Use robust estimated cache
-                     elif hasattr(self, 'estimated_total_cache') and self.estimated_total_cache:
-                         est_visual_per_line = self.estimated_total_cache / max(1, total_logical)
-
                      # FALLBACK: Use byte-based estimation
                      elif hasattr(buf, 'file') and buf.file and hasattr(buf.file, 'mm'):
                          total_bytes = len(buf.file.mm)
@@ -5051,10 +5207,10 @@ class Renderer:
                     allow_approximation=self.use_fast_approximation
                 )
                 current_ln -= 1
-    
+
         # Update anchor
         self.visual_line_anchor = (visual_line, logical_line)
-    
+
         # Find which visual line within this logical line
         wrap_points = self.get_wrap_points_for_line(cr, buf, logical_line, ln_width, viewport_width)
         for vis_idx, (start_col, end_col) in enumerate(wrap_points):
@@ -5448,10 +5604,7 @@ class Renderer:
 
         # Visual UTF-8 byte index for Pango (cluster-correct)
         def visual_byte_index(text, col):
-            b = 0
-            for ch in text[:col]:
-                b += len(ch.encode("utf-8"))
-            return b
+            return len(text[:col].encode("utf-8"))
 
         # --- THEMED BACKGROUND (uses cached color from update_colors_for_theme) ---
         r, g, b, a = self.editor_background_color
@@ -5464,9 +5617,12 @@ class Renderer:
         layout = PangoCairo.create_layout(cr)
         layout.set_font_description(self.font)
         layout.set_auto_dir(True)
+        if hasattr(self, 'tab_array') and self.tab_array:
+            layout.set_tabs(self.tab_array)
 
         total = buf.total()
         ln_width = self.calculate_line_number_width(cr, total)
+        self.last_ln_width = ln_width # Cache for consistency in hit-testing
 
         # Calculate how many visual lines can fit
         max_vis = (alloc.height // self.line_h) + 1
@@ -5593,6 +5749,16 @@ class Renderer:
                 # --- DRAW SEARCH MATCHES ---
                 if search_matches and ln in search_matches:
                     ranges = search_matches[ln]
+                    
+                    # Optimization: Set layout text ONCE for all matches in this line
+                    final_text = text_segment if text_segment else " "
+                    layout.set_text(final_text, -1)
+                    
+                    # Pre-calculate common metrics
+                    rtl = line_is_rtl(text_segment)
+                    text_w, _ = layout.get_pixel_size()
+                    base_x = self.calculate_text_base_x(rtl, text_w, alloc.width, ln_width, scroll_x)
+
                     for s_col, e_col in ranges:
                         # Intersect with current visual line segment
                         seg_s = max(s_col, col_start)
@@ -5600,27 +5766,6 @@ class Renderer:
                         
                         if seg_s < seg_e:
                             # Draw yellow highlight
-                            # Calculate pixel positions
-                            # Extract segment of text to measure
-                            
-                            # Note: simplistic measurement, assuming ltr for positions relative to base_x
-                            # But we need accurate visualization.
-                            # We can re-use layout but without setting text yet? No.
-                            # We need pixel offsets.
-                            
-                            # Optimized approach:
-                            # We are inside the loop where we process text_segment. 
-                            # But we haven't set text on layout yet for this segment.
-                            
-                            # Let's set the text on the layout now to calculate positions
-                            # (We do it again below, but it's cheap if efficient)
-                            final_text = text_segment if text_segment else " "
-                            layout.set_text(final_text, -1)
-                            
-                            # Convert cols to byte indices relative to text_segment start
-                            # seg_s is relative to line start. 
-                            # text_segment starts at col_start.
-                            # So index in text_segment is (seg_s - col_start)
                             
                             idx1 = visual_byte_index(text_segment, seg_s - col_start)
                             idx2 = visual_byte_index(text_segment, seg_e - col_start)
@@ -5631,11 +5776,6 @@ class Renderer:
                             x1 = r1_strong.x / Pango.SCALE
                             x2 = r2_strong.x / Pango.SCALE
                             
-                            # RTL check
-                            rtl = line_is_rtl(text_segment)
-                            text_w, _ = layout.get_pixel_size()
-                            base_x = self.calculate_text_base_x(rtl, text_w, alloc.width, ln_width, scroll_x)
-                            
                             h_x = base_x + min(x1, x2)
                             h_w = abs(x2 - x1)
                             
@@ -6171,6 +6311,12 @@ class VirtualTextView(Gtk.DrawingArea):
         # NEW: debounce triple click vs drag
         self._pending_triple_click = False
 
+        # Busy Overlay references (set by EditorWindow)
+        self._busy_overlay = None
+        self._busy_spinner = None
+        self._busy_label = None
+        self._pending_click = False
+
         # Search highlights
         self.search_matches = []  # List of (start_ln, start_col, end_ln, end_col, text)
         self.highlight_cache = {} # Dict {ln: [(start_col, end_col), ...]}
@@ -6194,8 +6340,29 @@ class VirtualTextView(Gtk.DrawingArea):
         self.install_im()
 
 
+
+    def create_hit_test_layout(self, text=""):
+        """Create a Pango layout for hit testing.
+        
+        Uses PangoCairo with a dummy surface to mimic Renderer.draw behavior
+        and ensure metrics match as closely as possible.
+        """
+        # Create a dummy surface/context if one isn't passed (we create internal)
+        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
+        cr = cairo.Context(surface)
+        
+        layout = PangoCairo.create_layout(cr)
+        layout.set_font_description(self.renderer.font)
+        
+        if hasattr(self.renderer, 'tab_array') and self.renderer.tab_array:
+            layout.set_tabs(self.renderer.tab_array)
+            
+        layout.set_auto_dir(True)
+        layout.set_text(text, -1)
+        return layout
+
     def create_text_layout(self, cr, text="", auto_dir=True):
-        """Create a Pango layout using renderer's font.
+        """Create a Pango layout with standard settings.
         
         Args:
             cr: Cairo context
@@ -6533,6 +6700,7 @@ class VirtualTextView(Gtk.DrawingArea):
         surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
         cr = cairo.Context(surface)
         ln_width = self.renderer.calculate_line_number_width(cr, total_logical)
+        self.renderer.last_ln_width = ln_width # Cache for consistency
         viewport_width = self.get_width()
         visible = max(1, self.get_height() // self.renderer.line_h)
         
@@ -6688,6 +6856,7 @@ class VirtualTextView(Gtk.DrawingArea):
             surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
             cr = cairo.Context(surface)
             ln_width = self.renderer.calculate_line_number_width(cr, total_lines)
+            self.renderer.last_ln_width = ln_width # Cache for consistency
             
             # Get total visual lines (uses caching for performance)
             total_visual = self.renderer.get_total_visual_lines(cr, self.buf, ln_width, viewport_width)
@@ -6780,7 +6949,7 @@ class VirtualTextView(Gtk.DrawingArea):
             return min(est, len(text))
         # -----------------------
 
-        layout = self.create_text_layout(cr, text)
+        layout = self.create_hit_test_layout(text)
 
         text_w, _ = layout.get_pixel_size()
         if px >= text_w:
@@ -7480,52 +7649,78 @@ class VirtualTextView(Gtk.DrawingArea):
         return False
 
     def copy_to_clipboard(self):
-        """Copy selected text to clipboard"""
-        text = self.buf.get_selected_text()
-        if text:
-            clipboard = self.get_clipboard()
-            clipboard.set_content(Gdk.ContentProvider.new_for_value(text))
+        """Copy selected text to clipboard with progress indicator"""
+        self.show_busy("Copying...")
+        
+        # Defer execution to allow UI to render the busy overlay
+        def _do_copy():
+            try:
+                text = self.buf.get_selected_text()
+                if text:
+                    clipboard = self.get_clipboard()
+                    clipboard.set_content(Gdk.ContentProvider.new_for_value(text))
+            finally:
+                self.hide_busy()
+            return False
+            
+        GLib.timeout_add(20, _do_copy)
 
     def cut_to_clipboard(self):
-        """Cut selected text to clipboard"""
-        text = self.buf.get_selected_text()
-        if text:
-            clipboard = self.get_clipboard()
-            clipboard.set_content(Gdk.ContentProvider.new_for_value(text))
-            self.buf.delete_selection()
-            self.queue_draw()
+        """Cut selected text to clipboard with progress indicator"""
+        self.show_busy("Cutting...")
+        
+        # Defer execution
+        def _do_cut():
+            try:
+                text = self.buf.get_selected_text()
+                if text:
+                    clipboard = self.get_clipboard()
+                    clipboard.set_content(Gdk.ContentProvider.new_for_value(text))
+                    # Pass the text we just fetched to delete_selection to avoid re-fetching it
+                    self.buf.delete_selection(provided_text=text)
+                    self.queue_draw()
+            finally:
+                self.hide_busy()
+            return False
+            
+        GLib.timeout_add(20, _do_cut)
 
     def paste_from_clipboard(self):
-        """Paste text from clipboard with better error handling"""
+        """Paste text from clipboard with better error handling and progress"""
         clipboard = self.get_clipboard()
         
         def paste_ready(clipboard, result):
             try:
                 text = clipboard.read_text_finish(result)
                 if text:
-                    self.buf.insert_text(text)
-                    
-                    # After paste, clear wrap cache and recalculate everything
-                    if self.renderer.wrap_enabled:
-                        self.renderer.wrap_cache.clear()
-                        self.renderer.total_visual_lines_cache = None
-                        self.renderer.estimated_total_cache = None
-                        self.renderer.visual_line_map = []
-                        self.renderer.edits_since_cache_invalidation = 0
-                    
-                    self.keep_cursor_visible()
-                    self.update_scrollbar()  # Update scrollbar range after paste
-                    self.update_im_cursor_location()
-                    self.queue_draw()
+                    self.show_busy("Pasting...")
+                    
+                    # Defer insert to allow UI update
+                    def _do_paste():
+                        try:
+                            self.buf.insert_text(text)
+                            
+                            # After paste, clear wrap cache and recalculate everything
+                            if self.renderer.wrap_enabled:
+                                self.renderer.wrap_cache.clear()
+                                self.renderer.total_visual_lines_cache = None
+                                self.renderer.estimated_total_cache = None
+                                self.renderer.visual_line_map = []
+                                self.renderer.edits_since_cache_invalidation = 0
+                        finally:
+                            self.hide_busy()
+                            self.queue_draw()
+                        return False
+                    
+                    GLib.timeout_add(20, _do_paste)
+                    
             except Exception as e:
+                # Handle finish error
                 error_msg = str(e)
-                # Silently ignore "No compatible transfer format" errors
-                # This happens when clipboard contains non-text data (images, etc.)
                 if "No compatible transfer format" not in error_msg:
                     print(f"Paste error: {e}")
-                # Optionally try to get text in a different way
                 self.try_paste_fallback()
-        
+
         clipboard.read_text_async(None, paste_ready)
 
     def try_paste_fallback(self):
@@ -7804,7 +7999,7 @@ class VirtualTextView(Gtk.DrawingArea):
         print(f"DEBUG: Click Pressed. Count={n_press}")
         self.grab_focus()
 
-        # Always use accurate xy_to_line_col - Pango hit-testing is fast enough
+        # Always use accurate xy_to_line_col
         ln, col = self.xy_to_line_col(x, y)
 
         mods = g.get_current_event_state()
@@ -8063,12 +8258,18 @@ class VirtualTextView(Gtk.DrawingArea):
         modifiers = g.get_current_event_state()
         shift_pressed = (modifiers & Gdk.ModifierType.SHIFT_MASK) != 0
 
-        # Temporary Pango context
+        # Create temporary cr for measurements
         surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
         cr = cairo.Context(surface)
-
-        ln_width = self.renderer.calculate_line_number_width(cr, self.buf.total())
-
+        
+        # Use cached line number width if available to ensure consistency with rendering
+        if hasattr(self.renderer, 'last_ln_width') and self.renderer.last_ln_width is not None and self.renderer.last_ln_width > 0:
+            ln_width = self.renderer.last_ln_width
+        else:
+            ln_width = self.renderer.calculate_line_number_width(cr, self.buf.total())
+            
+        # Adjust for scroll
+        base_x_check = x + self.scroll_x
         ln = self.scroll_line + int(y // self.renderer.line_h)
         ln = max(0, min(ln, self.buf.total() - 1))
 
@@ -8205,10 +8406,19 @@ class VirtualTextView(Gtk.DrawingArea):
 
     def xy_to_line_col(self, x, y):
         """Convert pixel coordinates to logical line and column."""
+        # We need a dummy surface for renderer methods that expect 'cr'
+        # even though we use create_hit_test_layout for metrics.
         surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
         cr = cairo.Context(surface)
 
-        ln_width = self.renderer.calculate_line_number_width(cr, self.buf.total())
+        # Use cached line number width if available to ensure consistency with rendering
+        if hasattr(self.renderer, 'last_ln_width') and self.renderer.last_ln_width is not None and self.renderer.last_ln_width > 0:
+            ln_width = self.renderer.last_ln_width
+        else:
+            # Fallback: calculate using widget context (accurate)
+            layout = self.create_hit_test_layout(str(self.buf.total()))
+            w, _ = layout.get_pixel_size()
+            ln_width = w + 15
         viewport_width = self.get_width()
 
         # ------------------------------------------------------------
@@ -8360,9 +8570,19 @@ class VirtualTextView(Gtk.DrawingArea):
             
             if self.renderer.wrap_enabled:
                 # Word wrap mode: scroll by visual lines
+                
+                # Use cached line number width if available
+                if hasattr(self.renderer, 'last_ln_width') and self.renderer.last_ln_width is not None and self.renderer.last_ln_width > 0:
+                    ln_width = self.renderer.last_ln_width
+                else:
+                    # Fallback: calculate using widget context
+                    layout = self.create_hit_test_layout(str(total_lines))
+                    w, _ = layout.get_pixel_size()
+                    ln_width = w + 15
+                
+                # Prepare dummy cr for logical_to_visual_line
                 surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
                 cr = cairo.Context(surface)
-                ln_width = self.renderer.calculate_line_number_width(cr, total_lines)
                 
                 # Calculate current visual line
                 current_visual = self.renderer.logical_to_visual_line(
@@ -8591,6 +8811,23 @@ class VirtualTextView(Gtk.DrawingArea):
         self.queue_draw()
 
 
+    # --------------------------------------------------------
+    # Busy Indicator Control
+    # --------------------------------------------------------
+    def show_busy(self, message="Processing..."):
+        """Show the busy overlay with a message."""
+        if self._busy_overlay:
+            self._busy_label.set_text(message)
+            self._busy_spinner.start()
+            self._busy_overlay.set_visible(True)
+            # Force UI update if possible, though usually handled by loop return
+            
+    def hide_busy(self):
+        """Hide the busy overlay."""
+        if self._busy_overlay:
+            self._busy_spinner.stop()
+            self._busy_overlay.set_visible(False)
+
     def on_click_released(self, g, n, x, y):
         print(f"DEBUG: Released. PendingClick={self._pending_click}. PendingTriple={self._pending_triple_click}")
         if self._pending_click:
@@ -11557,6 +11794,36 @@ class EditorWindow(Adw.ApplicationWindow):
         hscroll.set_valign(Gtk.Align.END)
         overlay.add_overlay(hscroll)
 
+        # ---------------------------------------------------------
+        # Busy Overlay (Spinner)
+        # ---------------------------------------------------------
+        busy_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
+        busy_box.add_css_class("busy-overlay") # Add rounding/background in CSS
+        busy_box.set_halign(Gtk.Align.CENTER)
+        busy_box.set_valign(Gtk.Align.CENTER)
+        
+        # Opaque background for visibility
+        # We can implement this via CSS provider, or just use a frame style
+        
+        spinner = Gtk.Spinner()
+        spinner.set_size_request(32, 32)
+        
+        busy_label = Gtk.Label(label="Processing...")
+        busy_label.add_css_class("title-2")
+        
+        busy_box.append(spinner)
+        busy_box.append(busy_label)
+        
+        # Initially hidden
+        busy_box.set_visible(False)
+        
+        overlay.add_overlay(busy_box)
+        
+        # Bind to editor view for control
+        editor.view._busy_overlay = busy_box
+        editor.view._busy_spinner = spinner
+        editor.view._busy_label = busy_label
+
         # Add close button for split views
         if add_close_button:
             close_btn = Gtk.Button()
@@ -11815,11 +12082,7 @@ class EditorWindow(Adw.ApplicationWindow):
         if editor:
             editor.view.grab_focus()
         
-        # Remove the chrome tab
-        for tab in self.tab_bar.tabs:
-            if hasattr(tab, '_page') and tab._page == page:
-                self.tab_bar.remove_tab(tab)
-                break
+
         
         # Update UI state
         self.update_ui_state()
